package org.jprotocol.protocol.tools

import org.jprotocol.framework.dsl.*
import org.jprotocol.codegen.*


abstract public class AbstractAPIGenerator  extends JavaGenerator {
    final protocol
    final String testConstr
    AbstractAPIGenerator(protocol, String pack) {
        super(pack, "${NameFormatter.formatName(protocol.name)}_API")
        testConstr = "${name}_Test"
        this.protocol = protocol
    }
    
    /**
     * Override this add additional javadoc
     */
    def additionalJavadoc(arg) {
    }
    
    /**
     * Override this to add additional constructors
     */
    def additionalConstructors() {
    }
	def additionalTestConstructors() {
		
	}
    /**
     * Override this to add additional import statements
     */
    def additionalImports() {
    	line 'import org.jprotocol.framework.test.ITestable'
    }
    
    def generate() {
        stdPackage()
        line 'import org.jprotocol.framework.api.*'
        line 'import org.jprotocol.framework.dsl.*'
		line 'import org.jprotocol.framework.test.*'
        if (hasQuantity()) {
        	line 'import org.jprotocol.quantity.Quantity'
        }
        line 'import java.util.Iterator'
        additionalImports()
        javadoc() {
        	comment protocol.name
            additionalJavadoc(protocol)
            comment "@note This class is generated by ${this.class.simpleName}.groovy"
        }
        simpleline(/@SuppressWarnings("all")/)
		def impl = getInterfaceType(name).equals("")? "": " implements " + getInterfaceType(name)
        block("public class ${name} extends AbstractDecoratedProtocolMessage implements ${protocol.direction}") {
            line (/public static final String NAME = "${protocol.name}"/)
            line "private final ${name} parent"
            
            block("public ${name}(IProtocolLayoutType type)") {
                line "this(new ProtocolMessage(type, false))"
            }
            block("public ${name}(IProtocolMessage protocol)") {
                line "this(protocol, false)"
            }
            block("private ${name}(IProtocolMessage protocol, boolean strBuilder)") {
                line "super(protocol, strBuilder)"
                line "this.parent = this"
            }
            
            additionalConstructors()
            
            
            block("static ${testConstr} createTest(StringBuilderProtocolMessage protocol)") {
                line ("return new ${testConstr}(protocol)")
            }

            block("public static class ${testConstr} extends ${name}") {
				additionalTestConstructors()
                block("${testConstr}(StringBuilderProtocolMessage protocol)") {
                    line "super(protocol, true)"
                }
            }
            
            genArgs()
			//TODO
			block("public <T extends APICommand<${name}>> $name execute(T...commands)") {
				block("for (APICommand<${name}> c: commands)") {
					line "c.execute(this)"
				}
				line "return this"
			}
        }
    }
    
    
    def genArgs() {
        protocol.arguments.each { arg ->
            genArg(arg, [])
        }
    }
    
    def genArg(arg, parents) {
        if (arg.isIndexedType()) {
            genIndexedArg(arg, parents)
        } else {
            genArgClass(arg, parents)
        }
    }
    
    def genArgClass(arg, parents) {
        def argName = NameFormatter.formatName(arg.name)
        javadoc() {
            comment "Argument: ${arg.name}"
            additionalJavadoc(arg)
        }
        block("public ${argName} get${argName}()") {
        	if (parents.size() == 0) {
        		line (/return new ${argName}(parent, protocol)/)
        	} else {
        		line (/return new ${argName}(parent, protocol, indexes)/)
        	}
        }
        block("public static class ${argName} extends AbstractDecoratedArgument") {
            line (/public static final String ${argName}_ArgName = "${arg.name}"/)
            line "private final ${name} parent"
            block("${argName}(${name} parent, IProtocolMessage protocol, int...indexes)") {
                line (/super(protocol, "${arg.name}", indexes)/)
                line "this.parent = parent"
            }
            if (arg.isStr()) {
                genStrGetSetMethods()
            } else {
                genGetSetMethods("Bit")
                if (arg.isEnumType()) {
                    //TODO
                	block("public static interface ${argName}_Command extends APICommand<${name}>") {
                	}
                    genEnumValues(arg, argName, parents)
                } else {
                    genGetSetMethods("")
                    genRealGetSetMethod()
                }
            }
        }
    }

    

    String propertyNameOf(String methodName) {
        int startIx = 0
        if (methodName.startsWith("is")) {
            startIx = 2
        } else if (methodName.startsWith("set")) {
            startIx = 3
        }
        methodName.substring(startIx)
    }
    
    
    def genGetSetMethods(str) {
        block("public int get${str}Value()") {
            line "return _get${str}Value(indexes)"
        }
        block("public ${name} set${str}Value(int value)") {
            if (str.isEmpty()) {
                line (/_set${str}Value(value + "", indexes)/)
            } else {
                line (/_set${str}Value(value, indexes)/)
            }
            line "return parent"
        }
    }
    
    def genStrGetSetMethods() {
        block("public String getValue()") {
            line "return _getValueAsStr(indexes)"
        }
        block("public ${name} setValue(String value)") {
            line (/_setValue(value, indexes)/)
            line "return parent"
        }
    }
    
    def genRealGetSetMethod() {
        block("public Quantity getRealQuantity()") {
            line "return _getRealQuantity(indexes)"
        }
        block("public ${name} setRealQuantity(Quantity value)") {
            line (/_setRealQuantity(value, indexes)/)
            line "return parent"
        }
        block("public double getRealValue()") {
            line "return _getRealValue(indexes)"
        }
        block("public ${name} setRealValue(double value)") {
            line (/_setRealValue(value, indexes)/)
            line "return parent"
        }
    }
    
    def genIndexedArg(arg, parents) {
        javadoc() {
            comment "Indexed argument: ${arg.name}"
        }
        def iArgName = NameFormatter.formatName(arg.name)
        def iterableName = "${iArgName}_Iterable"
        def iteratorName = "${iArgName}_Iterator"
        if (parents.size() == 0) {
            block("public ${iterableName} get${iArgName}()") {
                line "return new ${iterableName}(parent, protocol)"
            }
            block("public ${iArgName} get${iArgName}(int index)") {
                line "return new ${iArgName}(parent, protocol, index)"
            }
        } else {
	        block("public ${iterableName} get${iArgName}()") {
	            line "return new ${iterableName}(parent, protocol, indexes)"
	        }
            block("public ${iArgName} get${iArgName}(int index)") {
                line "return new ${iArgName}(parent, protocol, AbstractIterator.indexArrayOf(indexes, index))"
            }
        }
        block("public int getNrOf${iArgName}()") {
        	line "return get${iArgName}(0).getNrOf${iArgName}()"
        }
        block("public static class ${iterableName} implements Iterable<${iArgName}>") {
        	line "private final ${name} parent"
        	line "private final IProtocol protocol"
        	line "private final int[] indexes"
        	block("${iterableName}(${name} parent, IProtocol protocol, int...indexes)") {
        		line "this.parent = parent"
        		line "this.protocol = protocol"
        		line "this.indexes = indexes"
        	}
        	block("@Override public Iterator<${iArgName}> iterator()") {
        		line "return new ${iteratorName}()"
        	}
    		block("class ${iteratorName} extends AbstractIterator<${iArgName}>") {
    			line "private ${iArgName} obj"
    			line "private int _index"
    			line "private final int lastIndex"
    			block("${iteratorName}()") {
    				line "this.obj = new ${iArgName}(parent, protocol, indexArrayOf(indexes, _index))"
    				line "this.lastIndex = obj.getNrOf${iArgName}() - 1"
    			}
    			block("@Override public boolean hasNext()") {
    				line "return _index <= lastIndex"
    			}
    			block("@Override public ${iArgName} next()") {
    				line "assert hasNext()"
    				line "${iArgName} result = obj"
    				line "_index++"
    				line "obj = new ${iArgName}(parent, protocol, indexArrayOf(indexes, _index))"
    				line "return result"
    			}
    		}
        }
        
        block("public static class ${iArgName} extends AbstractDecoratedIndexedArg") {
            line "private final ${name} parent"
            line "private final int[] indexes"
            block("public ${iArgName}(${name} parent, IProtocol protocol, int...indexes)") {
                line "super(protocol)"
                line "this.indexes = indexes"
                line "this.parent = parent"
            }
            block("int getNrOf${iArgName}()") {
                line (/return nrOf("${arg.name}")/)
            }
            arg.children.each { subArg ->
                genArg(subArg, parents + arg)
            }
        }
    }

    /**
     * This should only be generated for protocols with one single version
     */
    def genIntValueConst(v, vName) {
        line "public static final int ${vName} = ${v.value}"
    }
    def genEnumValues(arg, argName, parents) {
        arg.values.each { v ->
            def vName = NameFormatter.formatName(v.name)
            genIntValueConst(v, vName)
//            line "public static final int ${vName} = ${v.value}"
            line(/public static final String ${vName}_NAME = "${v.name}"/)
            javadoc() {
            	additionalJavadoc(v)
            }
            block("public boolean is${vName}()") {
              line (/return _isValue("${v.name}", indexes)/)  
            }
            javadoc() {
            	additionalJavadoc(v)
            }
            block("public ${name} set${vName}()") {
                line (/_setValue("${v.name}", indexes)/)
                line "return parent"
            }
            //TODO
            block("public static ${argName}_Command get${vName}_Command()") {
            	line(/return new ${argName}_Command() { @Override public $name execute(${name} target) { target.getProtocol().setValue("${argName}", "${vName}"); return target; }}/) 
            }
            v.argTypes.each { subArg -> 
                genArg(subArg, parents)
            }
        }
    }
    

    def commaOf(str) {
        str.isEmpty() ? "" : ", ${str}"
    }
    
    boolean hasQuantity() {
    	new HasQuantityIter(protocol).hasQuantity()
    }
    abstract String getInterfaceType(String name);
}
